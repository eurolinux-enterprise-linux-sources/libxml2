commit 7609e8800bd18c0a88da0d7698e3cb70045408fc
Author: Daniel Veillard <veillard@redhat.com>
Date:   Wed May 6 19:33:11 2015 +0800

    CVE-2015-1819 Enforce the reader to run in constant memory
    
    One of the operation on the reader could resolve entities
    leading to the classic expansion issue. Make sure the
    buffer used for xmlreader operation is bounded.
    Introduce a new allocation type for the buffers for this effect.

diff --git a/include/libxml/tree.h b/include/libxml/tree.h
index b733589..baccfeb 100644
--- a/include/libxml/tree.h
+++ b/include/libxml/tree.h
@@ -74,7 +74,9 @@ typedef enum {
     XML_BUFFER_ALLOC_DOUBLEIT,	/* double each time one need to grow */
     XML_BUFFER_ALLOC_EXACT,	/* grow only to the minimal size */
     XML_BUFFER_ALLOC_IMMUTABLE, /* immutable buffer */
-    XML_BUFFER_ALLOC_IO		/* special allocation scheme used for I/O */
+    XML_BUFFER_ALLOC_IO,	/* special allocation scheme used for I/O */
+    XML_BUFFER_ALLOC_HYBRID,	/* exact up to a threshold, and doubleit thereafter */
+    XML_BUFFER_ALLOC_BOUNDED	/* limit the upper size of the buffer */
 } xmlBufferAllocationScheme;
 
 /**
diff --git a/tree.c b/tree.c
index ffebf06..bc47ba1 100644
--- a/tree.c
+++ b/tree.c
@@ -40,6 +40,7 @@
 #ifdef LIBXML_DEBUG_ENABLED
 #include <libxml/debugXML.h>
 #endif
+#include <libxml/parserInternals.h> /* for XML_MAX_TEXT_LENGTH */
 
 int __xmlRegisterCallbacks = 0;
 
@@ -6951,7 +6952,8 @@ xmlBufferSetAllocationScheme(xmlBufferPtr buf,
         (buf->alloc == XML_BUFFER_ALLOC_IO)) return;
     if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
         (scheme == XML_BUFFER_ALLOC_EXACT) ||
-        (scheme == XML_BUFFER_ALLOC_IMMUTABLE))
+        (scheme == XML_BUFFER_ALLOC_IMMUTABLE) ||
+	(scheme == XML_BUFFER_ALLOC_BOUNDED))
 	buf->alloc = scheme;
 }
 
@@ -7086,6 +7088,18 @@ xmlBufferGrow(xmlBufferPtr buf, unsigned int len) {
     size = buf->use + len + 100;
 #endif
 
+    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
+        /*
+	 * Used to provide parsing limits
+	 */
+        if ((buf->use + len >= XML_MAX_TEXT_LENGTH) ||
+	    (buf->size >= XML_MAX_TEXT_LENGTH)) {
+	    xmlTreeErrMemory("buffer error: text too long\n");
+	    return(-1);
+	}
+	if (size >= XML_MAX_TEXT_LENGTH)
+	    size = XML_MAX_TEXT_LENGTH;
+    }
     if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
         size_t start_buf = buf->content - buf->contentIO;
 
@@ -7196,6 +7210,15 @@ xmlBufferResize(xmlBufferPtr buf, unsigned int size)
         return(0);
 
     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);
+    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
+        /*
+	 * Used to provide parsing limits
+	 */
+        if (size >= XML_MAX_TEXT_LENGTH) {
+	    xmlTreeErrMemory("buffer error: text too long");
+	    return(0);
+	}
+    }
 
     /* Don't resize if we don't have to */
     if (size < buf->size)
@@ -7307,6 +7330,15 @@ xmlBufferAdd(xmlBufferPtr buf, const xmlChar *str, int len) {
 
     needSize = buf->use + len + 2;
     if (needSize > buf->size){
+	if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
+	    /*
+	     * Used to provide parsing limits
+	     */
+	    if (needSize >= XML_MAX_TEXT_LENGTH) {
+		xmlTreeErrMemory("buffer error: text too long");
+		return(-1);
+	    }
+	}
         if (!xmlBufferResize(buf, needSize)){
 	    xmlTreeErrMemory("growing buffer");
             return XML_ERR_NO_MEMORY;
@@ -7375,6 +7407,15 @@ xmlBufferAddHead(xmlBufferPtr buf, const xmlChar *str, int len) {
     }
     needSize = buf->use + len + 2;
     if (needSize > buf->size){
+	if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
+	    /*
+	     * Used to provide parsing limits
+	     */
+	    if (needSize >= XML_MAX_TEXT_LENGTH) {
+		xmlTreeErrMemory("buffer error: text too long");
+		return(-1);
+	    }
+	}
         if (!xmlBufferResize(buf, needSize)){
 	    xmlTreeErrMemory("growing buffer");
             return XML_ERR_NO_MEMORY;
diff --git a/xmlreader.c b/xmlreader.c
index 1e09fb7..ef13e28 100644
--- a/xmlreader.c
+++ b/xmlreader.c
@@ -2063,6 +2063,9 @@ xmlNewTextReader(xmlParserInputBufferPtr input, const char *URI) {
 		"xmlNewTextReader : malloc failed\n");
 	return(NULL);
     }
+    /* no operation on a reader should require a huge buffer */
+    xmlBufferSetAllocationScheme(ret->buffer,
+                                 XML_BUFFER_ALLOC_BOUNDED);
     ret->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
     if (ret->sax == NULL) {
 	xmlBufferFree(ret->buffer);
@@ -3586,22 +3589,36 @@ xmlTextReaderConstValue(xmlTextReaderPtr reader) {
 	    return(((xmlNsPtr) node)->href);
         case XML_ATTRIBUTE_NODE:{
 	    xmlAttrPtr attr = (xmlAttrPtr) node;
+	    const xmlChar *ret;
 
 	    if ((attr->children != NULL) &&
 	        (attr->children->type == XML_TEXT_NODE) &&
 		(attr->children->next == NULL))
 		return(attr->children->content);
 	    else {
-		if (reader->buffer == NULL)
-		    reader->buffer = xmlBufferCreateSize(100);
 		if (reader->buffer == NULL) {
-		    xmlGenericError(xmlGenericErrorContext,
-				    "xmlTextReaderSetup : malloc failed\n");
-		    return (NULL);
-		}
-	        reader->buffer->use = 0;
+		    reader->buffer = xmlBufferCreateSize(100);
+		    if (reader->buffer == NULL) {
+			xmlGenericError(xmlGenericErrorContext,
+					"xmlTextReaderSetup : malloc failed\n");
+			return (NULL);
+		    }
+
+		    xmlBufferSetAllocationScheme(reader->buffer,
+						 XML_BUFFER_ALLOC_BOUNDED);
+		} else
+		    xmlBufferEmpty(reader->buffer);
 	        xmlNodeBufGetContent(reader->buffer, node);
-		return(reader->buffer->content);
+		ret = xmlBufferContent(reader->buffer);
+		if (ret == NULL) {
+		    /* error on the buffer best to reallocate */
+		    xmlBufferFree(reader->buffer);
+		    reader->buffer = xmlBufferCreateSize(100);
+		    xmlBufferSetAllocationScheme(reader->buffer,
+						 XML_BUFFER_ALLOC_BOUNDED);
+		    ret = BAD_CAST "";
+		}
+		return(ret);
 	    }
 	    break;
 	}
